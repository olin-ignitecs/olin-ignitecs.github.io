{
  "name": "Olin-ignitecs.GitHub.io",
  "tagline": "",
  "body": "# Arduino basic functions\r\n## Preface\r\n\r\n\r\n### Background knowlege\r\n\r\nAn Arduino is a device that you can program with your computer to interface with the \r\nreal world. It can run motors, blink lights, communicate with sensors, and talk to \r\nother devices. With a couple addons, they can do some incredible things, like run \r\nrobots or even your home.\r\n\r\nArduinos are programmed in a subset of the `C` programming language. C is a \r\n*low-level language* meaning it takes longer to understand and it's a bit harder to \r\nprogam in than a *high-level language* like Python. However, it does have some \r\nadvantages that make devices like the Arduino possible. `C` is very close to \r\nhardware, meaning it's very good at controlling the hardware to do exactly what you \r\nwant. It's also *very* fast, and takes very few resources to run, which is why cheap \r\nplatforms like the Arduino exist, as they can use less powerful hardware to run.\r\n\r\n### Additional resources\r\n\r\nFor more complex and comprehensive resources, there are some excellent \r\n[books](https://hassanolity.files.wordpress.com/2013/11/the_c_programming_language_2.pdf) \r\nand [online tutorials](http://c.learncodethehardway.org/book/).\r\nIf you're ever stuck, or something is not working the way you expect it to, the \r\n[Ardino forums](http://forum.arduino.cc/) are a great place to search if someone has \r\nhad your issue before (chances are they have) or to ask for help py posting your own \r\nthread.\r\n\r\n## What you need to know to write `Arduino C`\r\n\r\n### Comments\r\n\r\nFirst off, we have the code comment. It is *not* actual code, it's just a marker \r\nthat tells the computer to ignore some text. This is useful to write some plain old \r\nenglish, often to explain what some bit of code is so when you look at it later, you \r\ndon't forget. Like little notes to yourslf. It can also be used to remove code when \r\nyou want to keep it around, but not have it run.\r\nThere are two kinds of comments, single and multi-line. Single line comments start \r\nwith `\\\\` and make everything after them until the end of the line a comment.\r\nMultiline comments can span multiple lines, and start with a `*/`, and end with a \r\n`*/`. This is usually for commenting out large blocks of text.\r\n\r\nFor example:\r\n\r\n    /*\r\n    A novice was trying to fix a broken Lisp machine by turning the power off and \r\non.\r\n    Knight, seeing what the student was doing, spoke sternly: “You cannot fix a \r\nmachine by just power-cycling it with no understanding of what is going wrong.”\r\n    Knight turned the machine off and on.\r\n    The machine worked.\r\n    */\r\n\r\n    // This too, is a comment\r\n\r\n### Variables\r\n\r\nVariables are ways of storing data in a symbol or label. You can think of it like a \r\nbox that holds something, for example an integer. Variables have to be declared \r\nbefore they can be used, along with their data type, so the computer knows what kind \r\nof data to put in the box.\r\n\r\nFor example, if I want to keep track of how many cows I own, I can declare a new \r\nvariable `cows`, and set it to the number of cows I have, say 5. I can do this with:\r\n\r\n    int cows;\r\n    cows = 5;\r\n\r\nor in one line with\r\n\r\n    int cows = 5;\r\n\r\nThe `int` at the beginning of the line tells the computer that `cows` can only hold \r\nsomething of type `int`, which are integers in `C`. It will fail and the computer \r\nwill complain with an error message about mismatched types if we give it something \r\nthat's not an integer.\r\n\r\nAnother important thing about variables is that they can *vary*. It's in the name! \r\nSo now if I get another cow, I have to tell the computer that. I can do that very \r\nsimply with:\r\n\r\n    cows = 6;\r\n\r\nIt's important to note that whenever the computer now sees the word `cows` in code, \r\nit will interpret it as the variables value. So if we tell the computer to print \r\n(teach them how to print maybe?) the value of `cows`, it will tell us 6.\r\n\r\n### Arduino specific functions\r\n\r\n#### `pinMode`\r\n\r\nNow that we know a little bit about variables and comments, we can learn about \r\nfunctions that the Arduino uses. \r\n\r\nOne of the first you'll encounter is `pinMode`. `pinMode` in general usage is \r\ncombined weth a variable like this:\r\n\r\n    int LED_pin = 13;\r\n    pinMode(LED_pin, OUTPUT);\r\n\r\nAs you can see, we made a new variable `LED_pin` and assigned it to the integer \r\n`13`. We then took that variable and told `pinMode` to use it, as well as the word \r\n`OUTPUT`, with the second line. The word `OUTPUT` is a *constant*, which is the same \r\nas a variable in that it can hold some data, but different in that it can't change, \r\nand you tell it to hold a value a little differently.\r\nThe `pinMode` word there is actually a **function call**, a concept which we'll get \r\ninto a litte later, that takes two **arguments**, in this case a number (supplied by \r\nthe variable `LED_pin` in this case) and a constant, either `INPUT` or `OUTPUT`.\r\n\r\nThis function sets up the pin whose number is the first argument to be an input or \r\nan output. That's why we used the variable `LED_pin` there, to make it easier to \r\nmake it easier to understand, read, and most importantly reuse when we need to use \r\nit again.\r\n\r\nIt matters if the pin is an output or an input for us to be able to use two other \r\nfunctions, `digitalWrite` and `digitalRead`, respectively.\r\n\r\n#### `digitalWrite` and `digitalRead`\r\n\r\nFirst off, a warning. **`digitalWrite` can only be used if the `pinMode` for that \r\npin has been set to `OUTPUT`, and `digitalRead` can only be used if it has been set \r\nto `INPUT`** \r\n\r\nThis is the purpose of `pinMode`, to constrain if we can read or write to that pin.\r\n\r\nWith that said, let's explain what they both do. Both functions interact with pins \r\nthat have been previously been told if they are an input pin or an output pin with \r\n`pinMode`. `digitalWrite` is called like this:\r\n\r\n    int LED_pin = 13;\r\n    pinMode(LED_pin, OUTPUT);\r\n    digitalWrite(LED_pin, HIGH);\r\n    digitalWrite(LED_pin, LOW);\r\n\r\nWe can see here that it takes a pin number and a constant, `HIGH` or `LOW`. This \r\nsets the pin on or off, respectively. Now if we hook pin 13 up to the long lead of \r\nthe LED, and the short lead to ground, we wold see......nothing! That's because C is \r\nreally fast, so it turns the LED on and then off after a really short period of time \r\nbecause both statements run pretty fast. This is why functions like `delay` exist, \r\nexplained in the next section.\r\n\r\n`digitalRead` can be called like this:\r\n\r\n\r\n    int button_pin = 12;\r\n    int LED_pin = 13;\r\n\r\n    int val; //did not assign a value to this variable, because the value will be \r\nassigned later\r\n    \r\n    pinMode(button_pin, INPUT);\r\n    pinMode(LED_pin, OUTPUT);\r\n\r\n    val = digitalRead(button_pin)\r\n    digitalWrite(LED_pin, val); \r\n\r\nThe key line in this is the `val = digitalRead(button_pin)`, which assigns the state \r\nof the button (pressed or not) to `val`, and then sets the LED to that value. \r\n\r\nThis means, for example, that if we had the button pulled down to ground with a pull \r\ndown resistor and when it's pushed, it will complete the circuit with a 5 volt \r\nsource. If we pushed the button and ran this code, the LED would stay on, but if we \r\ndidn't push the button, it wouldn't turn on.\r\n\r\n##### Optional\r\n\r\nInterestingly enough, this code gives us some insight into what `HIGH` and `LOW` \r\nactually are. since we declared `val` as only being able to hold integers, and we \r\nset the value of `LED_pin` with `digitalWrite`, which takes either `HIGH` or `LOW`, \r\nwe can infer that `HIGH` and `LOW` are actually integers!\r\n\r\nSure enough, `HIGH` is 1 and `LOW` is 0. Binary numbers!\r\n\r\n#### `delay`\r\n\r\n`delay` makes it possible to make the program run *slower* by making the program \r\npause. We need it to run slower because `C` can run much faster than we can \r\npercieve. This is a good thing, since it's much easier to slow things down than \r\nspeed them up.\r\n\r\n`delay` is called like this:\r\n\r\n    int LED_pin = 13;\r\n    pinMode(LED_pin, OUTPUT);\r\n    digitalWrite(LED_pin, HIGH);\r\n    delay(1000);\r\n    digitalWrite(LED_pin, LOW);\r\n\r\nso it's the same example as before, but now you can see the LED actually blink! It \r\nstays on for a second (`delay` takes a number of millieconds to do nothing) and then \r\nturns off.\r\n\r\n### Higher order functions and constructs\r\n\r\n#### `if`, `else`, and `else if` statements\r\n\r\n`if` statements are a crucial part of computer logic. It's what allows the computer \r\nto decide what course of action to take. A quick example of this in the context of \r\nthe concepts already introduced is\r\n\r\n    int LED_pin = 13;\r\n    int delay = 1000; // A once second delay\r\n    \r\n    pinMode(LED_pin, OUTPUT);\r\n\r\n    if (delay >= 1000) {\r\n        delay = 500;\r\n    }\r\n\r\n`else` clauses are what to do if the condition in the `()` is *not* met. An example of this is:\r\n\r\n    int num = X; //Fill this with a number\r\n    int isEven;\r\n\r\n    if (num % 2 == 0) { // the % checks the remainder if divided by by the next number.\r\n        isEven = 1;\r\n    } else {\r\n        isEven = 0;\r\n    }\r\n\r\nand lastly, `else if` is checking another condition is met, but only if the initial condition is not met. For example:\r\n\r\n    int num = X; // Fill this with a number\r\n\r\n    if (num == 0) {\r\n        Serial.println(\"Zero\");\r\n    } else if (num == 1) {\r\n        Serial.println(\"One\");\r\n    } else {\r\n        Serial.println(\"Too big!\");\r\n    }\r\n\r\n#### `for` and `while` loops\r\nLoops are constructs to do the same kind of instruction over and over.\r\n`while` loops check if a condidtion is true, and execute the body of the loop if the condition is true. This can be used to construct infinite loops. An example of this is:\r\n\r\n    int num = 0;\r\n    while (1) {\r\n        Serial.println(num);\r\n        num++;\r\n    }\r\n\r\nWhich prints all the numbers until something drastic happens like there's an integer overflow.\r\nChecking or tru conditions works the same way.\r\n\r\n    int num = 0;\r\n    while (num <= 10) {\r\n        Serial.println(num);\r\n        num++;\r\n    }\r\n\r\nThe loop and add and check conditional can be done with a `for` loop. It is a special case of the `while` loop.\r\n\r\n    for (num = 0; num <= 10; num++) {\r\n        Serial.println(num);\r\n    }\r\n\r\n![A for loop](http://www.arduino.cc/en/uploads/Reference/ForLoopIllustrated.png)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}